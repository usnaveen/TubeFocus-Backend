Instructions for Building the Unified YouTube Relevance Scorer1. Project GoalYour primary objective is to refactor and combine the logic from four separate Python scripts into a single, robust application. This new application will determine the relevance of a YouTube video to a user's learning goal by analyzing its title, description, tags, and category.The final system must be adaptive. It will start with default weights for each of the four scores and will use Linear Regression based on user feedback to learn better, more accurate weights over time. The final output score should be on a scale of 0 to 100.2. Analyze the Source FilesBefore you begin, thoroughly analyze the four provided Python scripts to understand their unique models and logic.test_description_scoring.py:What it does: Performs a deep, multi-faceted analysis of the video's title and description combined.Models: Uses both a SentenceTransformer (all-MiniLM-L6-v2) and a CrossEncoder (cross-encoder/ms-marco-MiniLM-L6-v2).Logic: Calculates four separate metrics and combines them in a weighted average. It also uses the goal deconstruction technique (splitting the goal by commas, 'and', etc.) to find the best possible match.test_title_scoring.py:What it does: Performs a fast, focused analysis of the video's title only.Model: Uses a SentenceTransformer (all-MiniLM-L6-v2).Logic: Uses goal deconstruction and then finds the maximum cosine similarity score between any sub-goal and the title.test_tag_scoring.py:What it does: Analyzes the video's list of tags.Model: Uses a Zero-Shot Classification model (facebook/bart-large-mnli).Logic: Compares the user's goal against each tag individually. It then calculates composite metrics like coverage and mean_confidence after filtering by a threshold. Note that this script does not use goal deconstruction.test_category_scoring.py:What it does: Analyzes the video's single assigned category.Model: Uses a Zero-Shot Classification model (facebook/bart-large-mnli).Logic: A simple, direct one-to-one comparison between the goal and the category name.3. Implementation Plan: A Modular, Learning SystemImplement the new application using a clean, modular structure. The following is a detailed guide.Step 3.1: Create the Project StructureOrganize the code into the following files:config.py: Manages loading and saving the dynamic weights for the scoring components from a weights.json file. Should contain default weights.youtube_api.py: Contains a single, efficient function fetch_video_details(video_id) that calls the YouTube API once to get the title, description, tags, and category ID. It should also include a helper to map the category ID to a human-readable name (e.g., '27' -> 'Education').scoring_modules.py: This file will contain the refactored logic from the four source scripts. Create four distinct functions:score_description(goal, title, description)score_title(goal, title)score_tags(goal, tags_list)score_category(goal, category_name)data_manager.py: Manages the user feedback data. It will save scoring results and user-provided scores to a feedback_data.csv.model_trainer.py: Contains the logic to train the LinearRegression model on the feedback data and update the weights.json file.main.py: The main entry point that orchestrates the entire process.requirements.txt: List all necessary libraries (pandas, scikit-learn, transformers, sentence-transformers, torch, requests).Step 3.2: Implement the Scoring LogicRefactor the source scripts into the functions within scoring_modules.py. Ensure each function returns a single, normalized score between 0 and 1.Apply Goal Deconstruction: The score_description and score_title functions must use the goal deconstruction logic (splitting the goal string and finding the max score). The score_tags and score_category functions should use their original logic.Step 3.3: Implement the Weighted AverageIn main.py, create a function to calculate the final score.Formula: Final Score = (w_desc * S_desc) + (w_title * S_title) + ...Handle Missing Data: This is critical. If a video has no tags, the score_tags function will return 0. In this case, the weight for tags (w_tags) must be redistributed proportionally among the other available scores (description, title, category). The sum of the weights used in the calculation must always equal 1.Final Scaling: Multiply the final 0-1 score by 100.Step 3.4: Implement the Machine Learning Feedback LoopThis is the adaptive component.Collect Feedback: In main.py, after displaying the final score, prompt the user to provide their own score (0-100).Save Data: Use the function in data_manager.py to save the four calculated scores (features) and the user's score (target) to feedback_data.csv.Trigger Training: In model_trainer.py, create a function train_and_update_weights(). This function should:Load the feedback_data.csv.Only proceed if there are enough data points (e.g., at least 5).Train a sklearn.linear_model.LinearRegression model.Extract the model's coefficients (model.coef_). These are the new, learned weights.Normalize the weights by taking their absolute value and dividing by their sum to ensure they add up to 1.Use the function in config.py to save these new, normalized weights to weights.json.Orchestrate: Call the train_and_update_weights() function from main.py after new feedback is successfully saved.By following these detailed instructions, you will create the intelligent, self-improving YouTube relevance scorer as discussed.